import os
import logging
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from app.models import Course, db, User
from flask import Flask
import requests
from app.services.file_processor import FileProcessor
from app.services.vector_db import VectorDB

logger = logging.getLogger(__name__)

API_BASE_URL = "http://127.0.0.1:5000/api/telegram"  # –ê–¥—Ä–µ—Å –≤–∞—à–µ–≥–æ Flask API

class CourseBot:
    def __init__(self, app: Flask):
        if not app:
            raise ValueError("Flask application must be provided")

        self.app = app
        self.token = os.environ.get('TELEGRAM_BOT_TOKEN')
        if not self.token:
            raise ValueError("TELEGRAM_BOT_TOKEN not found in environment variables")

        logger.info("Initializing Telegram bot...")
        self.bot = Bot(token=self.token)
        self.dp = Dispatcher()
        self._register_handlers()
        logger.info("Bot handlers registered successfully")

    def _register_handlers(self):
        """–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –∫–æ–º–∞–Ω–¥"""
        try:
            self.dp.message.register(self.start_handler, Command("start"))
            self.dp.message.register(self.register_handler, Command("register"))
            self.dp.message.register(self.auth_handler, Command("auth"))
            self.dp.message.register(self.list_courses_handler, Command("courses"))
            self.dp.message.register(self.help_handler, Command("help"))
            self.dp.message.register(self.ask_handler, Command("ask"))  # –ù–æ–≤—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤
            self.dp.callback_query.register(
                self.course_callback_handler,
                lambda c: c.data.startswith('course_')
            )
            self.dp.callback_query.register(
                self.materials_callback_handler,
                lambda c: c.data.startswith('materials_')
            )
        except Exception as e:
            logger.error(f"Error registering handlers: {e}", exc_info=True)
            raise

    async def start_handler(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
        try:
            logger.info(f"Start command received from user {message.from_user.id}")
            welcome_text = (
                "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç —Å–∏—Å—Ç–µ–º—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫—É—Ä—Å–∞–º–∏!\n\n"
                "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                "/register - –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è\n"
                "/auth - –í–æ–π—Ç–∏ –≤ —Å–∏—Å—Ç–µ–º—É\n"
                "/courses - –ü—Ä–æ—Å–º–æ—Ç—Ä —Å–ø–∏—Å–∫–∞ –∫—É—Ä—Å–æ–≤\n"
                "/ask - –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å –ø–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º –∫—É—Ä—Å–∞\n"
                "/help - –ü–æ–º–æ—â—å –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è"
            )
            await self.bot.send_message(chat_id=message.chat.id, text=welcome_text)
        except Exception as e:
            logger.error(f"Error in start handler: {e}", exc_info=True)
            await self.bot.send_message(chat_id=message.chat.id, text="‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã")

    async def register_handler(self, message: types.Message):
        """–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ API"""
        try:
            logger.info(f"Register command received from user {message.from_user.id}")
            if len(message.text.split()) < 2:
                await message.reply("–í–≤–µ–¥–∏—Ç–µ email –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: /register <email>")
                return

            email = message.text.split(maxsplit=1)[1]
            data = {
                "telegram_id": message.from_user.id,
                "username": message.from_user.username or message.from_user.first_name,
                "email": email
            }
            response = requests.post(f"{API_BASE_URL}/register", json=data).json()

            if response.get("success"):
                await message.reply("‚úÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!")
            else:
                await message.reply(f"‚ùå –û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: {response.get('error')}")

        except Exception as e:
            logger.error(f"Error in register handler: {e}", exc_info=True)
            await message.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏")

    async def auth_handler(self, message: types.Message):
        """–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ API"""
        try:
            logger.info(f"Auth command received from user {message.from_user.id}")
            data = {"telegram_id": message.from_user.id}
            response = requests.post(f"{API_BASE_URL}/auth", json=data).json()

            if response.get("success"):
                user = response.get("user")
                await message.reply(f"‚úÖ –í—ã –≤–æ—à–ª–∏ –∫–∞–∫ {user['username']} ({user['email']})")
            else:
                await message.reply(f"‚ùå –û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞: {response.get('error')}")

        except Exception as e:
            logger.error(f"Error in auth handler: {e}", exc_info=True)
            await message.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ —Å–∏—Å—Ç–µ–º—É")

    async def help_handler(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /help"""
        try:
            help_text = (
                "üîç –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞:\n\n"
                "1Ô∏è‚É£ /start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n"
                "2Ô∏è‚É£ /register <email> - –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è\n"
                "3Ô∏è‚É£ /auth - –í–æ–π—Ç–∏ –≤ —Å–∏—Å—Ç–µ–º—É\n"
                "4Ô∏è‚É£ /courses - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫—É—Ä—Å–æ–≤\n"
                "5Ô∏è‚É£ /ask <id_–∫—É—Ä—Å–∞> <–≤–æ–ø—Ä–æ—Å> - –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å –ø–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º –∫—É—Ä—Å–∞\n"
                "6Ô∏è‚É£ /help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ\n\n"
                "–ü–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –∫—É—Ä—Å–∞ –≤—ã —Å–º–æ–∂–µ—Ç–µ:\n"
                "üìö –ü—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –º–∞—Ç–µ—Ä–∏–∞–ª—ã –∫—É—Ä—Å–∞\n"
                "üìù –ü–æ–ª—É—á–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞—Ö\n"
                "‚ùì –ó–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –ø–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º"
            )
            await message.reply(help_text)
        except Exception as e:
            logger.error(f"Error in help handler: {e}", exc_info=True)
            await message.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã")

    async def list_courses_handler(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /courses"""
        try:
            with self.app.app_context():
                courses = Course.query.all()
                if not courses:
                    await message.answer("üìö –ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫—É—Ä—Å–æ–≤")
                    return

                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(
                        text=f"üìò {course.title}",
                        callback_data=f"course_{course.id}"
                    )]
                    for course in courses
                ])

                await message.answer("üìö –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫—É—Ä—Å—ã:", reply_markup=keyboard)
                logger.info(f"Courses listed for user {message.from_user.id}")
        except Exception as e:
            logger.error(f"Error in list courses handler: {e}")
            await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∫—É—Ä—Å–æ–≤")

    async def course_callback_handler(self, callback: types.CallbackQuery):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –∫—É—Ä—Å–∞"""
        try:
            course_id = int(callback.data.split('_')[1])
            with self.app.app_context():
                course = Course.query.get(course_id)
                if not course:
                    await callback.answer("‚ùå –ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return

                text = f"üìò {course.title}\n\n{course.description or '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'}"
                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(
                        text="üìö –ú–∞—Ç–µ—Ä–∏–∞–ª—ã –∫—É—Ä—Å–∞",
                        callback_data=f"materials_{course_id}"
                    )]
                ])

                await callback.message.edit_text(text, reply_markup=keyboard)
                await callback.answer()
        except Exception as e:
            logger.error(f"Error in course callback handler: {e}")
            await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")

    async def materials_callback_handler(self, callback: types.CallbackQuery):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ –∫—É—Ä—Å–∞"""
        try:
            course_id = int(callback.data.split('_')[1])
            with self.app.app_context():
                course = Course.query.get(course_id)
                if not course:
                    await callback.answer("‚ùå –ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return

                materials = course.materials
                if not materials:
                    await callback.message.edit_text("–í —ç—Ç–æ–º –∫—É—Ä—Å–µ –ø–æ–∫–∞ –Ω–µ—Ç –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤")
                    await callback.answer()
                    return

                text = f"üìö –ú–∞—Ç–µ—Ä–∏–∞–ª—ã –∫—É—Ä—Å–∞ {course.title}:\n\n"
                for material in materials:
                    text += f"üìù {material.title}\n"
                    if material.files:
                        for file in material.files:
                            text += f"üìé {file.filename}\n"
                    text += "\n"

                await callback.message.edit_text(text)
                await callback.answer()
        except Exception as e:
            logger.error(f"Error in materials callback handler: {e}")
            await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")

    async def ask_handler(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /ask –¥–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤ –ø–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã
            command_parts = message.text.split(maxsplit=2)
            if len(command_parts) < 3:
                await message.reply(
                    "–î–ª—è –ø–æ–∏—Å–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç:\n"
                    "/ask <id_–∫—É—Ä—Å–∞> <–≤–∞—à_–≤–æ–ø—Ä–æ—Å>\n"
                    "–ù–∞–ø—Ä–∏–º–µ—Ä: /ask 1 –ß—Ç–æ —Ç–∞–∫–æ–µ –≤–µ–∫—Ç–æ—Ä–Ω–∞—è –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö?"
                )
                return

            # –ü–æ–ª—É—á–∞–µ–º ID –∫—É—Ä—Å–∞ –∏ –≤–æ–ø—Ä–æ—Å
            try:
                course_id = int(command_parts[1])
            except ValueError:
                await message.reply("ID –∫—É—Ä—Å–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
                return

            question = command_parts[2]

            with self.app.app_context():
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫—É—Ä—Å–∞
                course = Course.query.get(course_id)
                if not course:
                    await message.reply("‚ùå –ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫ –∫—É—Ä—Å—É
                user = User.query.filter_by(telegram_id=str(message.from_user.id)).first()
                if not user or not user.has_access_to_course(course):
                    await message.reply("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –∫—É—Ä—Å—É")
                    return

                # –ü–æ–∏—Å–∫ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤
                await message.reply("üîç –ò—â—É –æ—Ç–≤–µ—Ç –Ω–∞ –≤–∞—à –≤–æ–ø—Ä–æ—Å...")
                search_results = FileProcessor.search_similar_documents(question, top_k=3)

                if not search_results:
                    await message.reply("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —è –Ω–µ –Ω–∞—à–µ–ª —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ –≤–∞—à–µ–º—É –≤–æ–ø—Ä–æ—Å—É")
                    return

                # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
                response = "üìö –í–æ—Ç —á—Ç–æ —è –Ω–∞—à–µ–ª –ø–æ –≤–∞—à–µ–º—É –≤–æ–ø—Ä–æ—Å—É:\n\n"
                for idx, result in enumerate(search_results, 1):
                    response += f"{idx}. {result.get('text', '–¢–µ–∫—Å—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç')}\n\n"

                await message.reply(response)
                logger.info(f"Answered question for user {message.from_user.id} about course {course_id}")

        except Exception as e:
            logger.error(f"Error in ask handler: {e}", exc_info=True)
            await message.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –≤–æ–ø—Ä–æ—Å–∞")

    async def start_polling(self):
        """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        try:
            logger.info("Starting bot polling...")
            await self.dp.start_polling(self.bot)
        except Exception as e:
            logger.error(f"Error starting bot: {e}")
            raise
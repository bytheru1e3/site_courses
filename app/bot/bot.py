import os
import logging
import asyncio
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from app.models import Course, db, User
from flask import Flask
import requests
from app.services.vector_db import VectorDB
from app.ai import answer_question

logger = logging.getLogger(__name__)

API_BASE_URL = "http://127.0.0.1:5000/api/telegram"  # –ê–¥—Ä–µ—Å –≤–∞—à–µ–≥–æ Flask API

class CourseBot:
    def __init__(self, app: Flask):
        if not app:
            raise ValueError("Flask application must be provided")

        self.app = app
        self.token = os.environ.get('TELEGRAM_BOT_TOKEN')
        if not self.token:
            raise ValueError("TELEGRAM_BOT_TOKEN not found in environment variables")

        logger.info("Initializing Telegram bot...")
        self.bot = Bot(token=self.token)
        self.dp = Dispatcher()
        self.user_states = {}
        self._register_handlers()
        logger.info("Bot handlers registered successfully")

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è VectorDB
        self.vector_db_path = os.path.join(os.getcwd(), "app", "data")
        logger.info(f"Vector DB path: {self.vector_db_path}")

    def _register_handlers(self):
        """–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –∫–æ–º–∞–Ω–¥"""
        try:
            self.dp.message.register(self.start_handler, Command("start"))
            self.dp.message.register(self.register_handler, Command("register"))
            self.dp.message.register(self.auth_handler, Command("auth"))
            self.dp.message.register(self.list_courses_handler, Command("courses"))
            self.dp.message.register(self.help_handler, Command("help"))
            self.dp.message.register(self.process_question)  # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤ –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –∫—É—Ä—Å–∞
            self.dp.callback_query.register(
                self.course_callback_handler,
                lambda c: c.data.startswith('course_')
            )
            self.dp.callback_query.register(
                self.materials_callback_handler,
                lambda c: c.data.startswith('materials_')
            )
            self.dp.callback_query.register(
                self.after_question_callback_handler,
                lambda c: c.data in ['ask_new_question', 'end_dialog']
            )
        except Exception as e:
            logger.error(f"Error registering handlers: {e}", exc_info=True)
            raise

    async def start_handler(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
        try:
            logger.info(f"Start command received from user {message.from_user.id}")
            welcome_text = (
                "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç —Å–∏—Å—Ç–µ–º—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫—É—Ä—Å–∞–º–∏!\n\n"
                "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                "/courses - –ü—Ä–æ—Å–º–æ—Ç—Ä —Å–ø–∏—Å–∫–∞ –∫—É—Ä—Å–æ–≤\n"
                "/help - –ü–æ–º–æ—â—å –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è"
            )
            await self.bot.send_message(chat_id=message.chat.id, text=welcome_text)
        except Exception as e:
            logger.error(f"Error in start handler: {e}", exc_info=True)
            await self.bot.send_message(chat_id=message.chat.id, text="‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã")

    async def help_handler(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /help"""
        try:
            help_text = (
                "üîç –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞:\n\n"
                "1Ô∏è‚É£ /start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n"
                "2Ô∏è‚É£ /courses - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫—É—Ä—Å–æ–≤\n"
                "3Ô∏è‚É£ /help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ\n\n"
                "–ö–∞–∫ –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å:\n"
                "1. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /courses\n"
                "2. –í—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å –∏–∑ —Å–ø–∏—Å–∫–∞\n"
                "3. –ó–∞–¥–∞–π—Ç–µ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å\n"
                "4. –ü–æ–ª—É—á–∏—Ç–µ –æ—Ç–≤–µ—Ç —Å —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π"
            )
            await message.reply(help_text)
        except Exception as e:
            logger.error(f"Error in help handler: {e}", exc_info=True)
            await message.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã")

    async def process_question(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–æ–ø—Ä–æ—Å–æ–≤ –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –∫—É—Ä—Å–∞"""
        try:
            user_id = message.from_user.id
            user_state = self.user_states.get(user_id)

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ–∂–∏–¥–∞–µ–º –ª–∏ –º—ã –≤–æ–ø—Ä–æ—Å –æ—Ç —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            if not user_state or not user_state.get('waiting_for_question'):
                return

            course_id = user_state['course_id']
            question = message.text

            with self.app.app_context():
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫—É—Ä—Å–∞
                course = Course.query.get(course_id)
                if not course:
                    await message.reply("‚ùå –ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫ –∫—É—Ä—Å—É
                user = User.query.filter_by(telegram_id=str(message.from_user.id)).first()
                if not user or not user.has_access_to_course(course):
                    await message.reply("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –∫—É—Ä—Å—É")
                    return

                # –ü–æ–∏—Å–∫ –æ—Ç–≤–µ—Ç–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤–µ–∫—Ç–æ—Ä–Ω–æ–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
                await message.reply("üîç –ò—â—É –æ—Ç–≤–µ—Ç –Ω–∞ –≤–∞—à –≤–æ–ø—Ä–æ—Å...")

                try:
                    answer = answer_question(question, self.vector_db_path)

                    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏
                    keyboard = InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="üìù –ó–∞–¥–∞—Ç—å –Ω–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å", callback_data="ask_new_question")],
                        [InlineKeyboardButton(text="‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data="end_dialog")]
                    ])

                    if not answer or "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —è –Ω–µ –Ω–∞—à–µ–ª –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏" in answer:
                        await message.reply(
                            "‚ùå –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —è –Ω–µ –Ω–∞—à–µ–ª —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ –≤–∞—à–µ–º—É –≤–æ–ø—Ä–æ—Å—É.\n"
                            "üí° –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π –∫—É—Ä—Å.",
                            reply_markup=keyboard
                        )
                        return

                    # –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º
                    full_response = (
                        f"üìö <b>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –ø–æ –∫—É—Ä—Å—É</b>\n"
                        f"<i>{course.title}</i>\n\n"
                        f"‚ùì <b>–í–∞—à –≤–æ–ø—Ä–æ—Å:</b>\n{question}\n\n"
                        f"üîç <b>–ù–∞–π–¥–µ–Ω–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:</b>\n{answer}"
                    )

                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç —Å —Ä–∞–∑–±–∏–µ–Ω–∏–µ–º –Ω–∞ —á–∞—Å—Ç–∏ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
                    await self.send_split_message(
                        chat_id=message.chat.id,
                        text=full_response,
                        parse_mode="HTML",
                        reply_markup=keyboard
                    )
                    logger.info(f"Answered question for user {message.from_user.id} about course {course_id}")

                except Exception as e:
                    logger.error(f"Error processing question: {str(e)}", exc_info=True)
                    await message.reply(
                        "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                        reply_markup=keyboard
                    )

                # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–æ–ø—Ä–æ—Å–∞
                self.user_states.pop(user_id, None)

        except Exception as e:
            logger.error(f"Error processing question: {e}", exc_info=True)
            await message.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –≤–æ–ø—Ä–æ—Å–∞")
            if user_id in locals():
                self.user_states.pop(user_id, None)

    async def after_question_callback_handler(self, callback: types.CallbackQuery):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–µ–π—Å—Ç–≤–∏–π –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –≤–æ–ø—Ä–æ—Å"""
        try:
            action = callback.data

            if action == "ask_new_question":
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ –∫—É—Ä—Å–æ–≤ –¥–ª—è –Ω–æ–≤–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞
                with self.app.app_context():
                    courses = Course.query.all()
                    if not courses:
                        await callback.message.edit_text("üìö –ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫—É—Ä—Å–æ–≤")
                        return

                    keyboard = InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(
                            text=f"üìò {course.title}",
                            callback_data=f"ask_course_{course.id}"
                        )]
                        for course in courses
                    ])

                    await callback.message.edit_text(
                        "üìö –í—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É —Ö–æ—Ç–∏—Ç–µ –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å:",
                        reply_markup=keyboard
                    )

            elif action == "end_dialog":
                await callback.message.edit_text(
                    "‚úÖ –î–∏–∞–ª–æ–≥ –∑–∞–≤–µ—Ä—à–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /courses, —á—Ç–æ–±—ã –∑–∞–¥–∞—Ç—å –Ω–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å."
                )

            await callback.answer()

        except Exception as e:
            logger.error(f"Error in after question callback handler: {e}")
            await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")

    async def register_handler(self, message: types.Message):
        """–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ API"""
        try:
            logger.info(f"Register command received from user {message.from_user.id}")
            if len(message.text.split()) < 2:
                await message.reply(
                    "–í–≤–µ–¥–∏—Ç–µ email –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: /register <email>\n"
                    "–ù–∞–ø—Ä–∏–º–µ—Ä: /register user@example.com"
                )
                return

            email = message.text.split(maxsplit=1)[1]
            data = {
                "telegram_id": message.from_user.id,
                "username": message.from_user.username or message.from_user.first_name,
                "email": email
            }
            response = requests.post(f"{API_BASE_URL}/register", json=data).json()

            if response.get("success"):
                await message.reply(
                    "‚úÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!\n"
                    "–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—É /courses –¥–ª—è –ø–æ–∏—Å–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤ –º–∞—Ç–µ—Ä–∏–∞–ª–∞—Ö –∫—É—Ä—Å–æ–≤."
                )
            else:
                await message.reply(f"‚ùå –û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: {response.get('error')}")

        except Exception as e:
            logger.error(f"Error in register handler: {e}", exc_info=True)
            await message.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏")

    async def auth_handler(self, message: types.Message):
        """–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ API"""
        try:
            logger.info(f"Auth command received from user {message.from_user.id}")
            data = {"telegram_id": message.from_user.id}
            response = requests.post(f"{API_BASE_URL}/auth", json=data).json()

            if response.get("success"):
                user = response.get("user")
                await message.reply(
                    f"‚úÖ –í—ã –≤–æ—à–ª–∏ –∫–∞–∫ {user['username']} ({user['email']})\n"
                    "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /courses –¥–ª—è –ø–æ–∏—Å–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤ –º–∞—Ç–µ—Ä–∏–∞–ª–∞—Ö –∫—É—Ä—Å–æ–≤."
                )
            else:
                await message.reply(
                    f"‚ùå –û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞: {response.get('error')}\n"
                    "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /register –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏."
                )

        except Exception as e:
            logger.error(f"Error in auth handler: {e}", exc_info=True)
            await message.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ —Å–∏—Å—Ç–µ–º—É")

    async def list_courses_handler(self, message: types.Message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /courses"""
        try:
            with self.app.app_context():
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                user = User.query.filter_by(telegram_id=str(message.from_user.id)).first()
                if not user:
                    await message.answer(
                        "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /register <email>"
                    )
                    return

                courses = Course.query.all()
                if not courses:
                    await message.answer("üìö –ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫—É—Ä—Å–æ–≤")
                    return

                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(
                        text=f"üìò {course.title}",
                        callback_data=f"course_{course.id}"
                    )]
                    for course in courses
                ])

                await message.answer(
                    "üìö –í—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å –¥–ª—è –ø–æ–∏—Å–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏–ª–∏ –∑–∞–¥–∞–Ω–∏—è –≤–æ–ø—Ä–æ—Å–∞:",
                    reply_markup=keyboard
                )
                logger.info(f"Courses listed for user {message.from_user.id}")

        except Exception as e:
            logger.error(f"Error in list courses handler: {e}")
            await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∫—É—Ä—Å–æ–≤")

    async def course_callback_handler(self, callback: types.CallbackQuery):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –∫—É—Ä—Å–∞"""
        try:
            course_id = int(callback.data.split('_')[1])
            with self.app.app_context():
                course = Course.query.get(course_id)
                if not course:
                    await callback.answer("‚ùå –ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π –∫—É—Ä—Å –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                user_id = callback.from_user.id
                self.user_states[user_id] = {
                    'waiting_for_question': True,
                    'course_id': course_id
                }

                text = (
                    f"üìò –ö—É—Ä—Å: {course.title}\n\n"
                    f"{course.description or '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'}\n\n"
                    "‚úçÔ∏è –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å –ø–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º —ç—Ç–æ–≥–æ –∫—É—Ä—Å–∞.\n"
                    "–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å –≤ —Å–ª–µ–¥—É—é—â–µ–º —Å–æ–æ–±—â–µ–Ω–∏–∏."
                )

                await callback.message.edit_text(text)
                await callback.answer()

        except Exception as e:
            logger.error(f"Error in course callback handler: {e}")
            await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")

    async def materials_callback_handler(self, callback: types.CallbackQuery):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ –∫—É—Ä—Å–∞"""
        try:
            course_id = int(callback.data.split('_')[1])
            with self.app.app_context():
                course = Course.query.get(course_id)
                if not course:
                    await callback.answer("‚ùå –ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return

                materials = course.materials
                if not materials:
                    await callback.message.edit_text("–í —ç—Ç–æ–º –∫—É—Ä—Å–µ –ø–æ–∫–∞ –Ω–µ—Ç –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤")
                    await callback.answer()
                    return

                text = f"üìö –ú–∞—Ç–µ—Ä–∏–∞–ª—ã –∫—É—Ä—Å–∞ {course.title}:\n\n"
                for material in materials:
                    text += f"üìù {material.title}\n"
                    if material.files:
                        for file in material.files:
                            text += f"üìé {file.filename}\n"
                    text += "\n"

                await callback.message.edit_text(text)
                await callback.answer()
        except Exception as e:
            logger.error(f"Error in materials callback handler: {e}")
            await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")

    async def start_polling(self):
        """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        try:
            logger.info("Starting bot polling...")
            await self.dp.start_polling(self.bot)
        except Exception as e:
            logger.error(f"Error starting bot: {e}")
            raise

    async def send_split_message(self, chat_id: int, text: str, parse_mode=None, reply_markup=None):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –¥–ª–∏–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è —Å —Ä–∞–∑–±–∏–µ–Ω–∏–µ–º –Ω–∞ —á–∞—Å—Ç–∏"""
        MAX_MESSAGE_LENGTH = 3000  # Maximum length for a single message

        try:
            if len(text) <= MAX_MESSAGE_LENGTH:
                await self.bot.send_message(
                    chat_id=chat_id,
                    text=text,
                    parse_mode=parse_mode,
                    reply_markup=reply_markup
                )
                return

            parts = []
            while text:
                if len(text) <= MAX_MESSAGE_LENGTH:
                    parts.append(text)
                    break

                # Find the best split point
                split_point = text[:MAX_MESSAGE_LENGTH].rfind('</b>')
                if split_point == -1:
                    split_point = text[:MAX_MESSAGE_LENGTH].rfind('</i>')
                if split_point == -1:
                    split_point = text[:MAX_MESSAGE_LENGTH].rfind('\n')
                if split_point == -1:
                    split_point = text[:MAX_MESSAGE_LENGTH].rfind('. ')
                if split_point == -1:
                    split_point = text[:MAX_MESSAGE_LENGTH].rfind(' ')
                if split_point == -1:
                    split_point = MAX_MESSAGE_LENGTH

                # Add part and prepare for next iteration
                part = text[:split_point]

                # Handle HTML tags
                if parse_mode == "HTML":
                    # Count open tags
                    open_b = part.count('<b>') - part.count('</b>')
                    open_i = part.count('<i>') - part.count('</i>')

                    # Close open tags
                    if open_b > 0:
                        part += '</b>' * open_b
                    if open_i > 0:
                        part += '</i>' * open_i

                parts.append(part)

                # Prepare next part
                text = text[split_point:].lstrip()

                # Restore HTML tags for next part
                if parse_mode == "HTML":
                    if open_b > 0:
                        text = '<b>' * open_b + text
                    if open_i > 0:
                        text = '<i>' * open_i + text

            # Send message parts
            total_parts = len(parts)
            for i, part in enumerate(parts):
                try:
                    # Add part indicator
                    if total_parts > 1:
                        if parse_mode == "HTML":
                            part += f"\n\n<i>üìÑ –ß–∞—Å—Ç—å {i+1} –∏–∑ {total_parts}</i>"
                        else:
                            part += f"\n\nüìÑ –ß–∞—Å—Ç—å {i+1} –∏–∑ {total_parts}"

                    # Send with appropriate markup
                    if i == total_parts - 1:  # Last part
                        await self.bot.send_message(
                            chat_id=chat_id,
                            text=part,
                            parse_mode=parse_mode,
                            reply_markup=reply_markup
                        )
                    else:
                        await self.bot.send_message(
                            chat_id=chat_id,
                            text=part,
                            parse_mode=parse_mode
                        )

                    # Add small delay between messages
                    if i < total_parts - 1:
                        await asyncio.sleep(0.5)

                except Exception as e:
                    logger.error(f"Error sending message part {i+1}: {str(e)}")
                    await self.bot.send_message(
                        chat_id=chat_id,
                        text=f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —á–∞—Å—Ç–∏ {i+1} —Å–æ–æ–±—â–µ–Ω–∏—è",
                        parse_mode=None
                    )

        except Exception as e:
            logger.error(f"Error in send_split_message: {str(e)}")
            await self.bot.send_message(
                chat_id=chat_id,
                text="‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è"
            )